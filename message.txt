Por si no lo vieron, en el grupo de telegram hay más finales de Pablo. Fui scrolleando y encontré varios más, los paso (no ví las consignas, solo copié y pegué, así que seguro pase alguno que ya figura en el PDF de finales de Pablo. Si es así, disculpen) (editado)
[12:02]
Final de noviembre 2024 (plan 2c-2023)
Tomo Pablo Barenbaum oral
1) Resolución
   2 afirmaciones en LPO
  a) Son equivalentes? Alguna implica a la otra? (una implicaba a la otra)
  b) Demostrar con resolucion la implicacion (me pregunto si se podía usar SLD en ese caso y por qué)
2) Haskell
  a) Cómo se puede definir fix en haskell
  b) Escribir foldl con fix sin recursión explícita
3) Calculo lambda
   a) En calculo lambda, podes hacer algo que se cuelga con fix?
  b) Escribir algo que se cuelga y mostrar la reducción
4) Javascript
  Un ejercicio que ya tomó antes, hacer una función que devuelve un iterador
  b) Hacer un unfold con un iterador
5) Prolog
   Escribir particiones(+N, +L, -P) que instancia P en todas las formas de particionar L en N listas
[12:03]
Paso lo que recuerdo del final que me tomó Pablo ayer. Era oral y tenía que ir explicando y resolviendo en el pizarrón.

1) a) Dar el tipo de una función en Haskell análoga a foldr, pero que tome dos listas y una función que procese las dos.
b) Implementar la función. Puede asumirse que las listas tienen la misma longitud. Puede usarse recursión explícita.
c) Usar la función para implementar zipWith sin recursión explícita.

2) Supongamos que, en cálculo lambda extendido con naturales, tenemos un algoritmo de inferencia de tipos que consiste en:
    
Reducir el término hasta una forma normal.
Si el resultado es un número cualquiera (0, 1, 2, ... representado con succ/pred), entonces el tipo es Nat. Si no, no.
¿Funcionaría bien este algoritmo? ¿Por qué o por qué no? Dar ejemplos.

3) Supongamos que extendemos el cálculo lambda con un operador de igualdad == que toma dos parámetros y se escribe de forma prefija, e.g. == 1 2.
a) Dar el tipo de este operador y extender el algoritmo de inferencia para tipar términos que lo usen.
b) Supongamos que queremos restringir el operador para que sólo pueda tomar elementos que no sean de tipo función. ¿Cómo debería modificarse el algoritmo de inferencia y/o el de Martelli-Montanari?

4) a) Definimos el tamaño de una fórmula de lógica de primer orden como la cantidad de instancias de símbolos de predicado que tiene. Al pasar una fórmula a forma clausal, ¿de qué orden es el crecimiento de su tamaño en función de la cantidad de operadores (&&, ||, ->)? ¿Lineal, cuadrático o exponencial?
b) ¿Cuál es la diferencia entre SLD y Prolog? Mostrar un programa y una consulta de Prolog para los que haya al menos una solución, pero Prolog no pueda hallar ninguno
[12:06]
Hola, paso lo que recuerdo, si alguien recuerda algo distinto o algo más avisen y edito el mensaje.
No anote ninguno de los enunciados así que probablemente difiera del enunciado original pero creo que la idea general masomenos está.
Fue escrito a libro abierto, duró unas 3 hs + 30 mins extra aprox, 4 preguntas. Tomo pablo.
[12:06]
Final PLP 2da fecha febrero/marzo (1/3/24)
1- Sea P un predicado unario, Z una constante que representa el 0 y S la función unaria que representa el sucesor (números naturales). S^n(Z) representa S(S(…S(Z)) n veces la S.
Dada la siguiente fórmula:
\forall x. P(S(S(x))) => P(x)
Demostrar usando resolución que para cualquier n en los naturales: 
P(S^n(Z)) => (P(Z) \lor P(S(Z)))
Ayuda: usar inducción, separando los casos 0 y 1.
[12:06]
2- En haskell no podemos operar modificando variables como en imperativo. Podemos simularlo tomando un entero adicional que representa el valor inicial de la variable y devolver adicionalmente un entero que representa el valor resultante de la variable luego de la ejecución.
Definimos en haskell el siguiente sinónimo type FunX a b = (a -> Int -> (b, Int))

a- Definir idX :: FunX a a Que representa el programa que no modifica la variable. Definir incX :: FunX a a Que incrementa el valor de la variable en 1.

b- Definir componer :: (FunX b c) -> (FunX a b) -> (FunX a c) Que compone 2 programas. EJ: CompX IncX IncX "hola" que si le pasa 5 como argumento, devuelve ("hola",7)

c- Usando árboles binarios, data AB a = Nil | Bin (AB a) a (AB a). Definir mapX :: (FunX a b) -> (FunX (AB a) (AB b)) Que funciona como el map en árboles binarios.
[12:07]
3- Iteradores en js, saben responder hayproximo(Booleano) y próximo (precondicion hayproximo) que devuelve el próximo 

a- Definir function naturales {…} que da un iterador que construye todos los naturales

b- Definir function intercalar(it1,it2){…} que devuelve un iterador que itera sobre ambos iteradores, debe recorrer los elementos de ambos sin importar si alguno de los iteradores es infinito

c- Definir function combinar(metaI){…} que devuelve un iterador que recorre todos los iteradores (metaI es un iterador que va dando iteradores) independientemente si alguno de ellos es infinito

Sol — ayer a las 12:07
4- Cálculo lambda solo con booleanos, M es un término cerrado de tipo Bool -> Bool verdadero o falso: (->> significa evalúa en muchos pasos)

a- M true ->> M’ entonces o bien M’ = true o bien M’ = false

b- M true ->> true o bien M true ->> false

c- M es un término en el cálculo lambda de booleanos, referencias y enteros. M true | mu ->> V | mu' con mu' potencialmente distinto a mu (es decir, puede ser igual a mu o no).
[12:08]
buenas, ahí voy escribiendo las preguntas de la mejor forma que me deje la memoria

1) sea una función f:(X,X)→X sobre un conjunto X, decimos que "e" es un elemento neutro de f ↔ ∀x:X. f(e,x)=f(x,e)=x 

Considerar el predicado "si f tiene un elemento neutro, es único"

a) Escribir el predicado como una formula de LPO

b) Decidir si la formula es válida. De serlo hay que probarlo con resolución. Y sino, mostrar una interpretación que la invalide.

2)Definimos una cadena K-equilibrada como una lista de 0s y 1s que contenga todas las listas posibles de k elementos (0s y 1s) entre sus elementos contiguos una sola vez cada una (una k-equilibrada de 2 es 11001). 

escribir el programa equilibrada(+K,-L) en prolog que devuelva todas las cadenas K-equilibradas de K. 
No hay por qué demostrar que funciona, pero hay que explicar los contratos e invariables de las auxiliares (?).

aca daba el ejemplo de dos respuestas de equilibrada(K,L) con K=3

pero no me las acuerdo 
xp

3) sean S1 y S2 substituciones de un goal de unificación G (aca talvez me estoy equivocando en algo), definimos que S1≤S2 significa que S1 es más general que S2. 

Decidir y justificar falso o verdadero:

a) o bien S1≤S2 o bien S2≤S1
b) si S1≤S2 y S2≤S1 entonces S1=S2
c) siempre existe T tal que T≤S1 y T≤S2, sin importar el G.
[12:08]
4) definiendo fix::(a→a)→a como fix f=f(fix f),
escribir foldL sin recursión explicita, usando fix
(talvez me falta alguna aclaración)

5) en lenguaje sigma,  definimos el tipo de un objeto [li=ς(xi)bi, i∈1..n] como [li:τi, i∈1..n] si el tipo de bi es τi cuando xi tiene el mismo tipo que el objeto. 

a) a partir de esto, escribir todas las reglas de tipado para objetos

b) discutir la posibilidad de añadir subtipado a estas reglas
[12:09]
1) agarra la regla de occur check y la cambia para que en vez de fallar, no hace nada y elimina la ecuación
a. Encontrar un problema de unificación donde dependiendo del orden de elección, falle o no falle
b. Idem pero dependiendo del orden de sustituciones distintas
c. Encontrar un conjunto de clausulas satisfactible desde el cual se pueda llegar a la clausula vacía con esta modificación del algoritmo de mgu
2) dar la lista de todos los predicados sobre naturales donde la preimagen de True sea finita
3) p(a); p(b); q(c); q(d);
r(X) :- not(not(X)), not(not(X))
Describir si falla o no, cual es el resultado y que variables se instancian en caso de que no falle
4) bool <: bool -> bool y viceversa
a. Dar el juicio de tipado de true true. Explicar que propiedad se perdió
b. tipar (\x. x x) (\x. x x) y dar un juicio de tipado. Explicar que propiedad se perdió.
5) calculo sigma. Define el objeto Zero que tiene un mensaje suc y otro que soporta hacer un fold en naturales con caso base 0.
a. Pidió evaluar un término
b. Definir el objeto dup que duplique un número usando el esquema de fold descrito en la consigna

Sumo lo que me acuerdo: 
5) 
a) Se define Zero = [ fold = ∆(i)i.z, suc = §(x)x.fold := ∆(i)i.s(x.fold(i))]
El termino a evaluar era zero.suc.fold(isZero)
b) el dup se esperaba que se use como n.fold(dup) y reduce al objeto que es el doble de n.

El triángulo es una lambda por las dudas
[12:09]
Prolog: dado un alfabeto generar todas las posibles combinaciones de símbolos (de cualquier tamaño, podían contener repetidos)

Lógica: me dio la fórmula “para todo x existe y tal que x = y” y me preguntó si era válida (rta: no es válida porque depende de que la definición de igualdad haga que sea reflexiva) me dijo que escriba esa propiedad y que pruebe que la fórmula es válida (igualdad reflexiva -> la fórmula que me dio) usando resolución 

Al usar resolución apareció un MGU y me pregunto sobre el algoritmo, que le diga la entrada, la salida y qué tiene que cumplir la salida. Me dio un conjunto de ecuaciones y me dijo que lo resuelva con el algoritmo: {x =•= f(y), y =•= x}

JavaScript: me dijo que tenes objetos que son iteradores: tienen un “hayProximo” que te dice si tenes un elemento más, y un “próximo” que te da el próximo elemento. Me pidió armar una función que tome dos iteradores y devuelva un iterador que vaya alternando entre los otros dos (si la función toma o y p queres un iterador que al pedirle próximo te de primero uno de o, si le volves a pedir próximo te da uno de p y así). Yo no llegue a armarla ni terminar la idea pero contandole lo que iba pensando alcanzó. 

Objetos: me pregunto si los juicios de evaluación de cálculo sigma se podrían hacer small step y que si podía lo escriba (alcanzó con escribir solo la regla de SEL) 

Cálculo lambda: me pregunto si teniendo solo Nat y Bool podía escribir programas que se traben (le dije que no y me preguntó por qué, quería que mencione el teorema de terminación). Me pregunto si agregando fix se podía y que de un ejemplo y lo mismo con referencias 

Haskell: me pregunto la diferencia entre  recursion estructural y primitiva y que de los tipos de las funciones que lo hacen en Haskell (foldr y recr) y me preguntó si podíamos escribir una en función de la otra para ambas(recr usando foldr y foldr usando recr)
[12:13]
Ahora me dí cuenta que podía haberlo puesto en un archivo de texto y luego convertirlo a PDF 
(Perdón, no uso mi cerebro nunca)