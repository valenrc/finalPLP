1- Haskell
estructura de LPO

```haskell
data Form =
  prop String   |
  And Form Form |
  Or Form Form  |
  Neg Form
```
a- foldForm
b- funcion para transformar en FNN (forma normal negada)
fnn :: Form -> Bool -> Form

>Por que toma un booleano??????

2- Razonamiento ecuacional e induccion estructural
como un map pero intercalando la aplicacion de f y g entre cada par de elementos en la lista

```haskell
{A0} alt f g [] = []
{A1} alt f g (x:xs) = f x : (alt g f xs)
```

Demostrar alt g1 g2 . alt f1 f2 = alt (g1 . f1) (g2 . f2)

3- Deduccion natural
Un nuevo termino de logica proposicional $\Delta$

$$\frac{\Gamma, \Delta \neg \tau \vdash \tau}{\Gamma \vdash \Delta \tau}\Delta_i$$
$$\frac{\Gamma \vdash \Delta \tau \quad \Gamma \vdash \Delta \neg \tau}{\Gamma \vdash \tau}\Delta_e$$

Demostrar:

a) $\vdash \tau \to \Delta \tau$
b) $\Delta \tau \vdash \Delta \neg \neg \tau$
c) $\Delta \tau , \Delta \neg \tau \vdash \sigma$ sugiere usar $\bot_e$ y el item anterior


4- 
Calculo lambda simulado en prolog, define $\lambda$-terminos como:

```prolog
var(X) :- nat(X).
lam(X,M) :- M termino lambda, nat(X).
app(M,N) :- M y N termino lambda.
```
a. Dar la lista de las variables libres de un termino
b. definir tama√±o(+M, -T)
c. generarLambdaTerminos(+XS, -M) generacion infinita